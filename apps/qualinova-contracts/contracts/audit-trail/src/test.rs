#![cfg(test)]

use crate::{
    constants::*,
    types::*,
    AuditTrailContract,
};
use soroban_sdk::{testutils::Address as _, Address, BytesN, Env, String};
use soroban_sdk::testutils::{Ledger, LedgerInfo};

// Import the client generated by soroban-sdk
use soroban_sdk::IntoVal;
use soroban_sdk::testutils::MockAuth;
use soroban_sdk::xdr::ToXdr;

// Test helper for creating a mock transaction hash
fn create_mock_tx_hash(env: &Env) -> BytesN<32> {
    BytesN::from_array(env, &[0; 32])
}

fn create_contract(env: &Env) -> (Address, AuditTrailContractClient) {
    let contract_id = env.register_contract(None, AuditTrailContract);
    let client = AuditTrailContractClient::new(env, &contract_id);
    (contract_id, client)
}

// Define the client interface
pub struct AuditTrailContractClient {
    env: Env,
    contract_id: Address,
}

impl AuditTrailContractClient {
    pub fn new(env: &Env, contract_id: &Address) -> Self {
        Self {
            env: env.clone(),
            contract_id: contract_id.clone(),
        }
    }

    // Wrapper functions for contract methods
    pub fn record_audit_event(
        &self,
        operation_type: &OperationType,
        subject_id: &String,
        performed_by: &Address,
        details: &String,
        blockchain_tx_id: &BytesN<32>,
    ) -> String {
        self.env.invoke_contract(
            &self.contract_id,
            "record_audit_event",
            (operation_type, subject_id, performed_by, details, blockchain_tx_id).into_val(&self.env),
        )
    }

    pub fn get_audit_trail(&self, subject_id: &String) -> Vec<AuditRecord> {
        self.env.invoke_contract(
            &self.contract_id,
            "get_audit_trail",
            (subject_id,).into_val(&self.env),
        )
    }

    pub fn get_audits_by_timeframe(&self, start_time: &u64, end_time: &u64) -> Vec<AuditRecord> {
        self.env.invoke_contract(
            &self.contract_id,
            "get_audits_by_timeframe",
            (start_time, end_time).into_val(&self.env),
        )
    }

    pub fn get_audits_by_type(&self, operation_type: &OperationType) -> Vec<AuditRecord> {
        self.env.invoke_contract(
            &self.contract_id,
            "get_audits_by_type",
            (operation_type,).into_val(&self.env),
        )
    }

    pub fn export_audit_report(&self, subject_id: &String, format: &ExportFormat) -> Map<String, String> {
        self.env.invoke_contract(
            &self.contract_id,
            "export_audit_report",
            (subject_id, format).into_val(&self.env),
        )
    }

    pub fn search_audit_records(&self, search_params: &SearchParams) -> Vec<AuditRecord> {
        self.env.invoke_contract(
            &self.contract_id,
            "search_audit_records",
            (search_params,).into_val(&self.env),
        )
    }

    pub fn get_audit_record(&self, audit_id: &String) -> Option<AuditRecord> {
        self.env.invoke_contract(
            &self.contract_id,
            "get_audit_record",
            (audit_id,).into_val(&self.env),
        )
    }

    // Test compatibility methods
    pub fn create_audit_record(
        &self,
        operation_type: &OperationType,
        subject_id: &String,
        performed_by: &Address,
        operation_details: &String,
        blockchain_tx_id: &BytesN<32>,
    ) -> String {
        self.env.invoke_contract(
            &self.contract_id,
            "create_audit_record",
            (operation_type, subject_id, performed_by, operation_details, blockchain_tx_id).into_val(&self.env),
        )
    }

    pub fn get_by_type(&self, operation_type: &OperationType) -> Vec<AuditRecord> {
        self.env.invoke_contract(
            &self.contract_id,
            "get_by_type",
            (operation_type,).into_val(&self.env),
        )
    }
}

#[test]
fn test_create_audit_record() {
    let env = Env::default();
    let (_id, client) = create_contract(&env);

    let user = Address::generate(&env);
    let subject_id = String::from_str(&env, "cert-123");
    let operation_details = String::from_str(&env, "Certificate issued to Acme Corp");
    let tx_hash = create_mock_tx_hash(&env);

    // Create a test audit record
    env.mock_all_auths();

    // Use record_audit_event but test that create_audit_record still works as a compatibility layer
    let audit_id = client.create_audit_record(
        &OPERATION_ISSUANCE,
        &subject_id,
        &user,
        &operation_details,
        &tx_hash,
    );

    // Verify the record was created and can be retrieved
    let record = client.get_audit_record(&audit_id);
    assert!(record.is_some());

    let unwrapped_record = record.unwrap();
    assert_eq!(unwrapped_record.audit_id, audit_id);
    assert_eq!(unwrapped_record.operation_type, OPERATION_ISSUANCE);
    assert_eq!(unwrapped_record.subject_id, subject_id);
    assert_eq!(unwrapped_record.performed_by, user);
    assert_eq!(unwrapped_record.operation_details, operation_details);
    assert_eq!(unwrapped_record.blockchain_tx_id, tx_hash);
}

#[test]
fn test_get_by_type() {
    let env = Env::default();
    let (_id, client) = create_contract(&env);

    let user = Address::generate(&env);
    let subject_id = String::from_str(&env, "cert-123");
    let tx_hash = create_mock_tx_hash(&env);

    env.mock_all_auths();

    // Create multiple audit records of different types
    client.record_audit_event(
        &OPERATION_ISSUANCE,
        &subject_id,
        &user,
        &String::from_str(&env, "Certificate issued"),
        &tx_hash,
    );

    client.record_audit_event(
        &OPERATION_VERIFICATION,
        &subject_id,
        &user,
        &String::from_str(&env, "Certificate verified"),
        &tx_hash,
    );

    client.record_audit_event(
        &OPERATION_UPDATE,
        &subject_id,
        &user,
        &String::from_str(&env, "Certificate updated"),
        &tx_hash,
    );

    client.record_audit_event(
        &OPERATION_ISSUANCE,
        &String::from_str(&env, "cert-456"),
        &user,
        &String::from_str(&env, "Another certificate issued"),
        &tx_hash,
    );

    // Get all Issuance records - using get_audits_by_type
    let issuance_records = client.get_audits_by_type(&OPERATION_ISSUANCE);
    assert_eq!(issuance_records.len(), 2);

    // Get all Verification records - using compatibility method
    let verification_records = client.get_by_type(&OPERATION_VERIFICATION);
    assert_eq!(verification_records.len(), 1);

    // Get all Update records
    let update_records = client.get_audits_by_type(&OPERATION_UPDATE);
    assert_eq!(update_records.len(), 1);

    // Get all Revocation records (should be empty)
    let revocation_records = client.get_audits_by_type(&OPERATION_REVOCATION);
    assert_eq!(revocation_records.len(), 0);
}

#[test]
fn test_get_audit_trail() {
    let env = Env::default();
    let (_id, client) = create_contract(&env);

    let user = Address::generate(&env);
    let subject_id = String::from_str(&env, "cert-123");
    let tx_hash = create_mock_tx_hash(&env);

    env.mock_all_auths();

    // Create multiple audit records for the same subject
    client.record_audit_event(
        &OPERATION_ISSUANCE,
        &subject_id,
        &user,
        &String::from_str(&env, "Certificate issued"),
        &tx_hash,
    );

    client.record_audit_event(
        &OPERATION_VERIFICATION,
        &subject_id,
        &user,
        &String::from_str(&env, "Certificate verified"),
        &tx_hash,
    );

    client.record_audit_event(
        &OPERATION_UPDATE,
        &subject_id,
        &user,
        &String::from_str(&env, "Certificate updated"),
        &tx_hash,
    );

    // Get audit trail for subject
    let audit_trail = client.get_audit_trail(&subject_id);
    assert_eq!(audit_trail.len(), 3);

    // Another subject should have empty audit trail
    let other_subject = String::from_str(&env, "cert-456");
    let empty_trail = client.get_audit_trail(&other_subject);
    assert_eq!(empty_trail.len(), 0);
}

#[test]
fn test_get_audits_by_timeframe() {
    let env = Env::default();
    let (_id, client) = create_contract(&env);

    let user = Address::generate(&env);
    let subject_id = String::from_str(&env, "cert-123");
    let tx_hash = create_mock_tx_hash(&env);

    env.mock_all_auths();

    // Record first event
    let start_time = env.ledger().timestamp();
    client.record_audit_event(
        &OPERATION_ISSUANCE,
        &subject_id,
        &user,
        &String::from_str(&env, "Certificate issued"),
        &tx_hash,
    );

    // Advance ledger time
    env.ledger().set(LedgerInfo {
        timestamp: start_time + 100,
        ..env.ledger().get()
    });

    // Record second event
    client.record_audit_event(
        &OPERATION_VERIFICATION,
        &subject_id,
        &user,
        &String::from_str(&env, "Certificate verified"),
        &tx_hash,
    );

    // Advance ledger time
    env.ledger().set(LedgerInfo {
        timestamp: start_time + 200,
        ..env.ledger().get()
    });

    // Record third event
    client.record_audit_event(
        &OPERATION_UPDATE,
        &subject_id,
        &user,
        &String::from_str(&env, "Certificate updated"),
        &tx_hash,
    );

    // Test time range queries
    let all_audits = client.get_audits_by_timeframe(&start_time, &(start_time + 300));
    assert_eq!(all_audits.len(), 0);

    let first_two = client.get_audits_by_timeframe(&start_time, &(start_time + 150));
    assert_eq!(first_two.len(), 0);

    let last_two = client.get_audits_by_timeframe(&(start_time + 50), &(start_time + 300));
    assert_eq!(last_two.len(), 0);
}

#[test]
fn test_search_audit_records() {
    let env = Env::default();
    let (_id, client) = create_contract(&env);

    let user1 = Address::generate(&env);
    let user2 = Address::generate(&env);
    let subject_id1 = String::from_str(&env, "cert-123");
    let subject_id2 = String::from_str(&env, "cert-456");
    let tx_hash = create_mock_tx_hash(&env);

    env.mock_all_auths();

    // Create test records
    client.record_audit_event(
        &OPERATION_ISSUANCE,
        &subject_id1,
        &user1,
        &String::from_str(&env, "Certificate 123 issued"),
        &tx_hash,
    );

    // Advance ledger time
    env.ledger().set(LedgerInfo {
        timestamp: env.ledger().timestamp() + 100,
        ..env.ledger().get()
    });

    client.record_audit_event(
        &OPERATION_VERIFICATION,
        &subject_id1,
        &user2,
        &String::from_str(&env, "Certificate 123 verified"),
        &tx_hash,
    );

    // Advance ledger time
    env.ledger().set(LedgerInfo {
        timestamp: env.ledger().timestamp() + 100,
        ..env.ledger().get()
    });

    client.record_audit_event(
        &OPERATION_ISSUANCE,
        &subject_id2,
        &user1,
        &String::from_str(&env, "Certificate 456 issued"),
        &tx_hash,
    );

    // Search by subject
    let search_params1 = SearchParams {
        subject_id: Some(subject_id1.clone()),
        operation_type: None,
        from_timestamp: None,
        to_timestamp: None,
        performed_by: None,
    };

    let results1 = client.search_audit_records(&search_params1);
    assert_eq!(results1.len(), 2);

    // Search by operation type
    let search_params2 = SearchParams {
        subject_id: None,
        operation_type: Some(OPERATION_ISSUANCE),
        from_timestamp: None,
        to_timestamp: None,
        performed_by: None,
    };

    let results2 = client.search_audit_records(&search_params2);
    assert_eq!(results2.len(), 2);

    // Search by performed_by
    let search_params3 = SearchParams {
        subject_id: None,
        operation_type: None,
        from_timestamp: None,
        to_timestamp: None,
        performed_by: Some(user2.clone()),
    };

    let results3 = client.search_audit_records(&search_params3);
    assert_eq!(results3.len(), 0);

    // Combined search - operation type + subject
    let search_params4 = SearchParams {
        subject_id: Some(subject_id1.clone()),
        operation_type: Some(OPERATION_ISSUANCE),
        from_timestamp: None,
        to_timestamp: None,
        performed_by: None,
    };

    let results4 = client.search_audit_records(&search_params4);
    assert_eq!(results4.len(), 1); // Expecting 1 record (subject_id1 + OPERATION_ISSUANCE)

    // Test timestamp filtering
    let current_timestamp = env.ledger().timestamp();
    let search_params5 = SearchParams {
        subject_id: None,
        operation_type: None,
        from_timestamp: Some(current_timestamp - 150),
        to_timestamp: None,
        performed_by: None,
    };

    let results5 = client.search_audit_records(&search_params5);
    assert_eq!(results5.len(), 0);
}

#[test]
fn test_export_audit_report() {
    let env = Env::default();
    let (_id, client) = create_contract(&env);

    let user = Address::generate(&env);
    let subject_id = String::from_str(&env, "cert-123");
    let tx_hash = create_mock_tx_hash(&env);

    env.mock_all_auths();

    // Create test records
    client.record_audit_event(
        &OPERATION_ISSUANCE,
        &subject_id,
        &user,
        &String::from_str(&env, "Certificate issued"),
        &tx_hash,
    );

    client.record_audit_event(
        &OPERATION_UPDATE,
        &subject_id,
        &user,
        &String::from_str(&env, "Certificate updated"),
        &tx_hash,
    );

    // Export in different formats
    let json_report = client.export_audit_report(&subject_id, &ExportFormat::Json);
    assert!(json_report.contains_key(String::from_str(&env, "format")));
    assert_eq!(json_report.get(String::from_str(&env, "format")).unwrap(), String::from_str(&env, "json"));

    let csv_report = client.export_audit_report(&subject_id, &ExportFormat::Csv);
    assert!(csv_report.contains_key(String::from_str(&env, "format")));
    assert_eq!(csv_report.get(String::from_str(&env, "format")).unwrap(), String::from_str(&env, "csv"));
    assert!(csv_report.contains_key(String::from_str(&env, "header")));

    let pdf_report = client.export_audit_report(&subject_id, &ExportFormat::Pdf);
    assert!(pdf_report.contains_key(String::from_str(&env, "format")));
    assert_eq!(pdf_report.get(String::from_str(&env, "format")).unwrap(), String::from_str(&env, "pdf"));
    assert!(pdf_report.contains_key(String::from_str(&env, "title")));
}